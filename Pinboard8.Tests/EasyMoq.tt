<#@ template debug="true" hostspecific="true" language="C#" #>
<#@ output extension=".cs" #>
<#@ assembly name="System.Core" #>
<#@ assembly name="$(TargetDir)WP-Fx.EasyMoq.Generator.dll" #> 
<#@ assembly name="$(TargetPath)" #>
<#@ import namespace="System" #>
<#@ import namespace="System.Collections.Generic" #>
<#@ import namespace="System.IO" #>
<#@ import namespace="System.Linq" #>
<#@ import namespace="System.Reflection" #>
<#@ import namespace="System.Threading.Tasks" #>
<#@ import namespace="KretschIT.WP_Fx.EasyMoq.Generator" #>
<#@ import namespace="KretschIT.WP_Fx.EasyMoq.Generator.Configurations" #>
<# this.Header(); #>

<# this.CommonNamespaces(); #>

namespace <#= this.Helper.TargetNamespace #>
{
	#region Registration

	[<#= this.Helper.RegistrationAttributeName #>]
	public sealed class <#= this.Helper.InitClassName #> : IEasyMoqRegistration
	{
		public void Register(IMockFactoryRegistration factory)
		{
<#			foreach(var info in this.Helper.MockableInfo)
            {
				if(!info.IsGeneric)
                {
#>
			factory.Register<<#= info.InterfaceName #>, <#= info.MockableName #>>(() => new <#= info.MockableName #>());
<#				}
				else
                {
					foreach(var genericVersion in info.GenericVersions)
                    {
						var genericArguments = this.ClassHelper.CreateGenericArgumentsWith(genericVersion);
						var mockable = info.MockableName + genericArguments;
#>
			factory.Register<<#= info.InterfaceName #><#= genericArguments #>, <#= mockable #>>(() => new <#= mockable #>());  
<#					}
				}
			}	
#>
        }
	}

	#endregion

<# 
	foreach(var info in this.Helper.MockableInfo)
    {
		var genericArguments = this.ClassHelper.CreateGenericArgumentsFor(info.InterfaceType);
		var interfaceImplementation = info.InterfaceName + genericArguments;
#>
	#region <#= info.MockableName #>

	class <#= info.MockableName #><#= genericArguments #> : Mockable<<#= interfaceImplementation #>>, <#= interfaceImplementation #><#= this.ClassHelper.GetGenericConstraintOf(info.InterfaceType.GetGenericArguments()) #>
	{
<#
		this.CreateEventsOf(info.InterfaceType);
		this.InsertLines(1);
		this.CreateMethodsOf(info.InterfaceType);
		this.InsertLines(1);
		this.CreatePropertiesOf(info.InterfaceType);
#>	}
	
	#endregion

<# 
    }
#>}

<#+ // Helper
	
	private IEasyMoqTemplateHelper helper;

	public IEasyMoqTemplateHelper Helper
	{
		 get
         {
			if(this.helper == null)
            {
				var assembly = this.GetTargetAssembly();
				this.helper = new EasyMoqTemplateHelper(new EasyMoqClassConfigReader(assembly));
            }
			return this.helper;
         }
		 set
		 {
			 this.helper = value;
         }
	}	

	private Assembly GetTargetAssembly()
    {
		var resolver = new AssemblyResolver();
		return resolver.GetAssembly(this.AssemblyName, AppDomain.CurrentDomain.GetAssemblies());
    }

	private string AssemblyName
    {
		get
		{
			var path = this.Host.ResolveAssemblyReference("$(TargetPath)");
			return Path.GetFileNameWithoutExtension(path);
        }
    }

	private IEasyMoqClassTemplateHelper classHelper;

	private IEasyMoqClassTemplateHelper ClassHelper
    {
		get
		{
			if(this.classHelper == null)
            {
				this.classHelper = new EasyMoqClassTemplateHelper(this.Helper.NameFactory);
            }
			return this.classHelper;
        }
    }

	#region Common

	private void InsertLines(int lines)
    {
		for(int i = 0; i < lines; i++)
        {
#><#= Environment.NewLine #><#+ 
        }

	}

	#region Header

	private void Header()
	{			
		this.LiceningNotice();
		this.AutoGeneratedNotice();
	}

	private void LiceningNotice()
    {
#>//
// *************************************************************************************
// WP-Framework
// 
// Developed by
// Lukas Kretschmar (lkretschmar.dev@bluewin.ch)
//
// Switzerland, Copyright (c) 2013 lkretschmar
// This content is released under the MIT License (http://opensource.org/licenses/MIT).
//     
// *************************************************************************************
//
//
<#+ 
    }

	private void AutoGeneratedNotice()
    {
#>
// ***********************************************************************************************************************************
// NOTICE!!
// This content is auto-generated. Any changes will be overriden the next time the template is changed or the custom-tool is executed.
// Generated at: <#= DateTime.Now.ToShortDateString() #> <#= DateTime.Now.ToShortTimeString() #>
//
// ***********************************************************************************************************************************
<#+ 
    }

	#endregion

	#region Namespaces

	private void CommonNamespaces()
    {
#>
using System;
using System.Reflection;
using KretschIT.WP_Fx.EasyMoq;
using KretschIT.WP_Fx.EasyMoq.Generator;
<#+
    }

	private void WriteNamespaces(IEnumerable<string> namespaces)
    {
		foreach(var n in namespaces)
        {
#>
using <#= n #>;
<#+
        }
    }

	#endregion

	#endregion

	#region Factory

	private void FactoryNamespaces()
    {
		this.WriteNamespaces(this.Helper.FactoryUsingNamespaces);
    }

	#endregion

	#region Mockable

	private void MockableNamespaces()
    {
		this.WriteNamespaces(this.Helper.MockablesUsingNamespaces);
    }

	#region Events

	private void CreateEventsOf(Type type)
    {
#>
		#region Events

<#+ 
		foreach(var e in this.ClassHelper.GetEventsOf(type))
        {
			this.CreateEvent(e);
			this.InsertLines(1);
        }
#> 
		#endregion
<#+
    }

	private void CreateEvent(EventInfo e)
    {
#> 
		public event <#= this.ClassHelper.GetUniqueNameOf(e.EventHandlerType) #><#= this.ClassHelper.CreateGenericArgumentsFor(e) #> <#= e.Name #>;

		public void Raise<#= e.Name #>Event(<#= this.ClassHelper.CreateArguments(this.ClassHelper.GetSignatureOf(e).GetParameters(), true) #>)
		{
			if(this.<#= e.Name #> != null)
			{
				this.<#= e.Name #>(<#= this.ClassHelper.CreateArguments(this.ClassHelper.GetSignatureOf(e).GetParameters(), false) #>);
			}
		}
<#+		 
    }

	#endregion


	#region Methods

	private void CreateMethodsOf(Type type)
    {
#>
		#region Methods

<#+ 
		foreach(var method in this.ClassHelper.GetMethodsOf(type))
        {
			this.CreateMethod(method);
			this.InsertLines(1);
        }
#> 
		#endregion
<#+ 
    }

	private void CreateMethod(MethodInfo method)
    {
#>
		public <#= this.ClassHelper.GetReturnType(method.ReturnType) #> <#= method.Name #><#= this.ClassHelper.CreateGenericArgumentsFor(method) #>(<#= this.ClassHelper.CreateArguments(method.GetParameters(), true) #>)<#= this.ClassHelper.GetGenericConstraintOf(method.GetGenericArguments()) #>
		{
<#+			
#>			<#= this.ClassHelper.HasReturnType(method.ReturnType) ? "return " : string.Empty #>this.Handler.Call(m => m.<#= method.Name #><#= this.ClassHelper.CreateGenericArgumentsFor(method) #>(<#= this.ClassHelper.CreateArguments(method.GetParameters(), false) #>));
<#+			
#>		}
<#+
    }

	#endregion

	#region Properties

	private void CreatePropertiesOf(Type type)
    {
#>
		#region Properties

<#+     var properties = this.ClassHelper.GetPropertiesOf(type);
		foreach(var property in properties)
        {
			this.CreateProperty(property, properties);
			this.InsertLines(1);			
        }

#>		#endregion
<#+ 
    }

	private void CreateProperty(PropertyInfo property, IEnumerable<PropertyInfo> properties)
    {
		bool isFirst = property.Equals(properties.First(p => p.Name == property.Name));
		var declaringType = this.ClassHelper.GetUniqueNameOf(property.DeclaringType);
		var constPropertyName = property.Name + "PropertyName";

		if(isFirst)
        {
#>		private const string <#= constPropertyName #> = "<#= property.Name #>";

<#+
        }
#>
		<#= isFirst ? "public " : string.Empty #><#= this.ClassHelper.GetReturnType(property.PropertyType) #> <#= !isFirst ? declaringType +"." : string.Empty #><#= property.Name #>
		{
<#+			
			if(isFirst)
            {
				if(property.CanRead)
				{
#>			get { return this.Handler.Get(m => m.<#= property.Name #>); }
<#+ 
				}
				if(property.CanWrite)
				{
					if(property.CanRead)
                    {
#>			set { this.Handler.Set(m => m.<#= property.Name #>, value); }
<#+					}
					else
					{
#>			set { this.Handler.Set(m => m.Property(<#= constPropertyName #>), value); }
<#+					
					}
				}
            }
			else
            {
				if(property.CanRead)
				{
#>			get { return this.Handler.Get(m => ((<#= declaringType #>)m).<#= property.Name #>); }
<#+ 
				}
				if(property.CanWrite)
				{
                    if (property.CanRead)
                    {                  
#>			set { this.Handler.Set(m => ((<#= declaringType #>)m).<#= property.Name #>, value); }
<#+					}
                    else
                    {
#>			set { this.Handler.Set(m => ((<#= declaringType #>)m).Property(<#= constPropertyName #>), value); }
<#+                 
					}
				}
            }
#>		}
<#+
    }



	#endregion

	#endregion
 #>

